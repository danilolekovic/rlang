#!/usr/bin/env ruby
# Rubinius WebAssembly VM
# Copyright (c) 2019-2020, Laurent Julliard and contributors
# All rights reserved.
#
# Rlang compiler
# Rlang is a subset of the Ruby language that can be transpiled
# to WAT and then compiled to WASM. The Rubinius WASM virtual
# machine is written in Rlang.
#
# Compile a Rlang source file to WAT file


require 'optparse'
require 'fileutils'
require_relative '../lib/utils/log'
require_relative '../lib/rlang'
require_relative '../lib/builder/ext/tempfile'

include Log
logger.level = Logger::INFO

# WAT to WASM compiler
WAT_COMPILER = 'wat2wasm'
raise "no wat2wasm compiler found" unless system('wat2wasm --help >/dev/null')

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: parser.rb [options] rlang_file.rb"

  opts.on("-I", "--load_path DIRECTORY", "specify $LOAD_PATH directory (may be used more than once)") do |dir|
    options[:load_path] ||= []
    options[:load_path] << dir
  end

  opts.on("-M", "--module", "WASM module name") do |v|
    options[:module] = v
  end

  opts.on("-m", "--memory SIZE", "WASM Memory size allocated in pages") do |size|
    options[:memory] = size
  end

  opts.on("-w", "--wat", "Generate WAT source file") do |v|
    options[:wat] = v
  end

  opts.on("-s", "--ast", "Generate Ruby AST file") do |v|
    options[:ast] = v
  end

  opts.on("-s", "--wasm", "Generate WASM bytecode file") do |v|
    options[:wasm] = v
  end

  opts.on("-o", "--output FILE", "Write output to file") do |file|
    options[:output] = file
  end

  opts.on("-v", "--verbose [LEVEL]", "Verbosity level (fatal, error, warn, info, debug)") do |level|
    options[:level] = level || 'INFO'
    logger.level = Kernel.const_get("Logger::#{options[:level].upcase}")
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!(ARGV)

options[:module] ||= ''
options[:memory] ||= 4
options[:load_path] ||= []

fh_out = options[:output] ? File.open(options[:output], 'w') : STDOUT

logger.formatter = proc do |severity, datetime, progname, msg|
  loc = caller_locations[3] # skip over the logger call itself
  "#{severity[0]}: #{File.basename(loc.path)}:#{loc.lineno}##{loc.label} > #{msg}\n"
end

if options[:ast]
  fh_in = ARGV.empty? ? STDIN : File.open(ARGV[0])
  fh_out.write(Parser::CurrentRuby.parse(File.read(fh_in)))
end

memory_section = "(memory $0 #{options[:memory]})\n(export \"memory\" (memory $0))\n"

if options[:wat] || options[:wasm]
  parser = Rlang::Parser::Parser.new(nil)
  parser.config[:LOAD_PATH] = options[:load_path]
  parser.config[:__FILE__] = File.expand_path(ARGV[0])
  wg = Rlang::Parser::WGenerator.new(parser)
  parser.wgenerator = wg
  parser.parse_file(File.expand_path(ARGV[0]))

  # Write WAT code in a temp file
  # Do not delete temp file when closing
  tf = Tempfile.new([File.basename(ARGV[0]), '.wat'])
  tf.persist! 
  tf << ";; Generated by Rlang compiler v#{Rlang::VERSION} on #{Time.now}\n"
  tf << "(module #{options[:module]}\n"
  tf << memory_section
  tf << "\n;; ======= EXPORT FUNCTIONS =======\n"
  tf << Rlang::Parser::Export.transpile
  tf << "\n;; ======= GLOBAL VARIABLES =======\n"
  tf << Rlang::Parser::Global.transpile
  tf << "\n;; ======= STATIC DATA =======\n"
  tf << Rlang::Parser::DAta.transpile
  tf << "\n;; ======= CODE =======\n"
  tf << wg.root.transpile
  tf << ")\n"
  tf.close

  if options[:wasm]
    ret = system("#{WAT_COMPILER} #{tf.path} -o #{options[:output]}")
    File.unlink(tf.path) if ret
  elsif options[:wat]
    if options[:output]
      FileUtils.mv(tf.path, options[:output])
    else
      STDOUT.write(File.read(tf.path))
    end
  end
end

exit 0

